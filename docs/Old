\input{./.econtexRoot}\documentclass[\econtexRoot/SolvingMicroDSOPs]{subfiles}

\begin{document}

\hypertarget{the-usual-theory}{}
\section{The Usual Theory}\label{sec:the-usual-theory}

Here we derive the Euler equation and some other standard results for the problem described above.

%\renewcommand{\ExEndStp}{\overrightarrow{\Ex}}
The first order condition for \eqref{eq:vNormed} with respect to ${c}_{\prd}$ is
\begin{equation}\begin{gathered}\begin{aligned}
      \uFunc^{{c}}({c}_{\prd})  & = \ExEndStp[\DiscFac \RNrm_{\prd+1}\PermGroFac_{\prd+1}^{1-\CRRA}{\vFunc}^{{m}}_{\MidStpNxt}({m}_{\prd+1})]  \label{eq:upceqEvtp1}
      \\                        & =  \ExEndStp[\DiscFac\Rfree\phantom{._{\prd+1}}\PermGroFac_{\prd+1}^{\phantom{1}-\CRRA}{\vFunc}^{{m}}_{\MidStpNxt}({m}_{\prd+1})]
    \end{aligned}\end{gathered}\end{equation}
and because the \handoutC{Envelope} theorem tells us that
\begin{equation}\begin{gathered}\begin{aligned}
      {\vFunc}^{{m}}_{\MidStp}({m}_{\prd})  & =  \Ex_{\BegStpNxt} [\DiscFac \Rfree \PermGroFac_{\prd+1}^{-\CRRA}{\vFunc}^{{m}}_{\MidStpNxt}({m}_{\prd+1})] \label{eq:envelope}
    \end{aligned}\end{gathered}\end{equation}
we can substitute the LHS of \eqref{eq:envelope} for the RHS of
(\ref{eq:upceqEvtp1}) to get
\begin{verbatimwrite}{./Equations/Envelope.tex}
  \begin{equation}\begin{gathered}\begin{aligned}
        \uFunc^{{c}}({c}_{\prd})  & = {\vFunc}^{{m}}_{\MidStp}({m}_{\prd})\label{eq:upcteqvtp}
      \end{aligned}\end{gathered}\end{equation}
\end{verbatimwrite}
\input{./Equations/Envelope.tex}\unskip
and rolling forward one {\interval},
\begin{equation}\begin{gathered}\begin{aligned}
      \uFunc^{{c}}({c}_{\prd+1})  & = \vFunc^{{m}}_{\MidStpNxt}({a}_{\prd}\RNrm_{\prd+1}+\TranShkEmp_{\prd+1}) \label{eq:upctp1EqVpxtp1}
    \end{aligned}\end{gathered}\end{equation}
so that substituting the LHS in equation (\ref{eq:upceqEvtp1}) finally gives us the Euler equation for consumption:
\begin{verbatimwrite}{./Equations/cEuler.tex}
  \begin{equation}\begin{gathered}\begin{aligned}
        \uFunc^{{c}}({c}_{\prd})  & = \ExEndStp[\DiscFac\Rfree \PermGroFac_{\prd+1}^{-\CRRA}\uFunc^{{c}}({c}_{\prd+1})] \label{eq:cEuler}.
      \end{aligned}\end{gathered}\end{equation}
\end{verbatimwrite}
\input{./Equations/cEuler.tex}\unskip

From the perspective of the beginning of {\interval} $\prd+1$ we can write the `arrival value' function and its first derivative as
\begin{verbatimwrite}{./Equations/vBegtpdefn.tex}
  \begin{equation}\begin{gathered}\begin{aligned}
        \vBegStpNxt({k}_{\prd+1})    & = \Ex_{\BegStpNxt}[\phantom{\Rfree}\PermGroFac\AdjVNxt {\vFunc}_{\MidStpNxt}(\overbrace{\RNrm_{\prd+1}{k}_{\prd+1}+{\TranShkEmp}_{\prd+1}}^{{m}_{\prd+1}})] \label{eq:vFuncBegtpdefn} \\
        \vPBegStpNxt({k}_{\prd+1}) & = \Ex_{\BegStpNxt}[\Rfree \PermGroFac^{\phantom{1}-\CRRA} {\vFunc}_{\MidStpNxt}^{{m}}({m}_{\prd+1})]
      \end{aligned}\end{gathered}\end{equation}
\end{verbatimwrite}\unskip
\input{./Equations/vBegtpdefn}\unskip
because they return the expected $t+1$ value and marginal value associated with arriving in {\interval} $\prd+1$ with any given amount of \textit{k}apital.

Finally, recalling that we obtain $\vEndStp({a}_{\prd}) = \DiscFac \vBegStpNxt({k}_{\prd+1})$ using ${k}_{\prd+1}={a}_{\prd}$, note for future use that we can write the Euler equation \eqref{eq:cEuler} more compactly as
\begin{verbatimwrite}{./Equations/upEqbetaOp.tex}
  \begin{equation}\begin{gathered}\begin{aligned}
        \uFunc^{{c}}({c}_{\prd})   & = \vEndStp^{{a}}({m}_{\prd}-{c}_{\prd}).
        \label{eq:upEqbetaOp}
      \end{aligned}\end{gathered}\end{equation}
\end{verbatimwrite}
\input{./Equations/upEqbetaOp.tex}\unskip

\hypertarget{summing-up}{}
\subsection{Summing Up}\label{subsec:summing-up}
For future reference, it will be useful here to write the full expressions for the distinct value functions at the {\Arrival} ($\BegMark$) and {\Decision} {\moves}.  % this is said two par ahead: (Recalling that the continuation-value function $\vEndStp(a)$ is provided to the solution algorithm as an input).

There is no need to use our {\interval}-identifying notation for the model's variables; $\kNrm$, for example, will have only one unique value over the course of the {\interval} and therefore a notation like $\kNrm_{\EndStp}$ would be pointless; the same is true of all other variables.

Recall that the continuation value function $\vFunc_{\EndStp}(\aNrm)=\DiscFac \vFunc_{\BegStpNxt}(\aNrm)$ is provided as an input to the current {\stg} Bellman problem.  Since within the scope of the solution of the current {\stg} there is only one such continuation value function, in the solution context there is no point in keeping the {\interval} subscript when we write this function.  The same point applies to all variables and functions in the {\stg}.  Given the continuation value function $\vEndStp$, the problem within the {\stg} can be written with only the {\move} indicators:
\begin{verbatimwrite}{./Equations/vBegStp}
  \begin{equation}\begin{gathered}\begin{aligned}
        \vFunc_{\arvl}(\kNrm) & = \Ex_{\arvl}[\vFunc(\overbrace{\kNrm \RNrm + \TranShkEmp}^{\mNrm})]  \label{eq:vBegStp}
      \end{aligned}\end{gathered}\end{equation}
\end{verbatimwrite}
\input{./Equations/vBegStp}\unskip
\begin{verbatimwrite}{./Equations/vMid}
  \begin{equation}\begin{gathered}\begin{aligned}
        \vFunc(\mNrm) & = \max_{\{{\cNrm}\}}~~\uFunc({\cNrm}) +\Ex[ \vFunc_{\cntn}(\overbrace{\mNrm-\cFunc}^{\aNrm})] \label{eq:vMid}
      \end{aligned}\end{gathered}\end{equation}
\end{verbatimwrite}
\input{./Equations/vMid}\unskip
% and
% \begin{verbatimwrite}{./Equations/vEndtdefn}
%   \begin{equation}\begin{gathered}\begin{aligned}
%         \vEndStp(\aNrm_{\prd}) & = \DiscFac \vBegStpNxt(\overbrace{\kNrm_{\prd+1}}^{\aNrm_{\prd}}) \label{eq:vEndtdefn}
%       \end{aligned}\end{gathered}\end{equation}
% \end{verbatimwrite}
%\input{./Equations/vEndtdefn}\unskip

\begin{comment}
  \subsection{Implementation in Python}

  The code implementing the tasks outlined each of the sections to come is available in the \texttt{\href{https://econ-ark.org/materials/SolvingMicroDSOPs}{SolvingMicroDSOPs}} jupyter notebook, written in \href{https://python.org}{Python}. The notebook imports various modules, including the standard \texttt{numpy} and \texttt{scipy} modules used for numerical methods in Python, as well as some user-defined modules designed to provide numerical solutions to the consumer's problem from the previous section. Before delving into the computational exercise, it is essential to touch on the practicality of these custom modules.

  \subsubsection{Useful auxilliary files}

  In this exercise, two primary user-defined modules are frequently imported and utilized. The first is the \texttt{gothic\_class} module, which contains functions describing the end-of-period value functions found in equations \eqref{eq:vBegStp} - \eqref{eq:vEnd} (and the corresponding first and second derivatives). %The advantage of defining functions in the code which decompose the consumer's optimal behavior in a given period will become evident in section \ref{subsec:transformation}

  The \texttt{resources} module is also used repeatedly throughout the notebook. This file has three primary objectives: (i) providing functions that discretize the continuous distributions from the theoretical model that describe the uncertainty a consumer faces, (ii) defining the utility function over consumption under a number of specifications, and (iii) enhancing the grid of end-of-period assets for which functions (such as those from the \texttt{gothic\_class} module) will be defined. These objectives will be discussed in greater detail and with respect to the numerical methods used to the problem in subsequent sections of this document.
\end{comment}

\end{document}
