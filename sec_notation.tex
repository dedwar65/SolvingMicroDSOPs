\input{./.econtexRoot}\documentclass[\econtexRoot/SolvingMicroDSOPs]{subfiles}

\begin{document}

\hypertarget{notation}{}
\section{Notation}\label{sec:notation}

\subsection{Periods, Stages, Steps}

The problem specified above assumes that the agent has only one decision problem to solve in any {period}.  In practice, it is increasingly common to model agents who have multiple choice {stage}s per {period}; an agent's problem might have, say, a consumption decision (call it the $\cFunc$ {stage}), a labor supply {stage} (call it $\labor$) and a choice of what proportion $\Shr$ of their assets to invest in a risky asset (the portfolio-choice {stage}).

The modeler might well want to explore whether the order in which the {stage}s are solved makes any difference, either to the substantive results or to aspects of the computational solution like speed and accuracy.

If, as in section \ref{sec:the-problem}, we hard-wire into the solution code for each {stage} an assumption that its successor {stage} will be something in particular (say, the consumption {stage} assumes that the portfolio choice is next), then if we want to change the order of the {stage}s (say, labor supply after consumption, followed by portfolio choice), we will need to re-hard-wire each of the stages to know particular things about its new successor (for example, the specifics of the distribution of the rate of return on the risky asset would need to be known by whatever {stage} precedes the portfolio choice {stage}).

But one of the cardinal insights of Bellman's (1957, ``Dynamic Programming'') original work is that \emph{everything that matters} for the solution to the current problem is encoded in a `continuation-value function.' %that incorporates \texttt{everything about the future} that is important to solution of the present stage.  %This point is important for a number of reasons, but here we will focus on one problem of ignoring it. Actual solution of the maximization problem as specified in \eqref{eq:vNormed} requires the current agent to have knowledge not only of the successor value function, but also of other aspects of the problem like the distributions of the future period's stochastic shocks. So any solution to the problem that directly uses in \eqref{eq:vNormed} will need to hard-wire into itself the specifics of the successor problem.

Using Bellman's insight, we describe here a framework for isolating the {stage} problems within a {period} from each other, and the {period} from its successors in any future {period}; the advantage of this is that the isolated {stage} and {period} problems will then be `modular': We can solve them in any order \textit{without changing any code}. After considering the {stage}-order $[\ell,\cFunc,\Shr]$, the modeler can costlessly reorder the {stage}s to consider, say, the order $[\ell,\Shr,\cFunc]$.\footnote{As long as the beginning-of-{stage} and end-of-{stage} value functions for the {stage}s all depend on the same state variables; see the discussion in section \ref{sec:multiple-control-variables} for further discussion.}

\subsection{Steps}

The key to the framework is distinguishing, within each {stage}'s Bellman problem, three {steps}:

\begin{enumerate}
\item \textbf{\Arrival}: Incoming state variables (e.g., $\kNrm$) are known, but any shocks associated with the period have not been realized and decision(s) have not yet been made
\item \textbf{\Decision}: All exogenous variables (like income shocks, rate of return shocks, and predictable income growth $\PermGroFac$) have been realized (so that, e.g., $\mNrm$'s value is known) and the agent solves the optimization problem
\item \textbf{\Continuation}: After all decisions have been made, their consequences are measured by evaluation of the continuing-value function at the values of the `outgoing' state variables (sometimes called `post-state' variables).
\end{enumerate}

%In the standard treatment in the literature, the (implicit) default assumption is that the {step} where the agent is solving a decision problem is the unique {step} at which the problem is defined.  This is what was done above, when (for example) in \eqref{eq:vNormed} we related the value $\vFunc$ of the current decision to the expectation of the future value $\vFunc_{\prd+1}$.  Here, instead, we want to encapsulate the current {stage}'s problem as a standalone object, which is solved by taking as given an exogenously-provided continuation-value function (in our case, $\vEndStg(a)$).

When we want to refer to a specific {step} in the {stage} we will do so by using an indicator which identifies that {step}.  Here we use the consumption {stage} problem described above to exemplify the usage:
\begin{center}
%  \mbox{%
    \begin{tabular}{r|c|c|l|l}
      {Step}         & Indicator               & State          & Usage                       & Explanation                                \\ \hline
      {\Arrival}      & $ \arvl $ & $\kNrm$ & $\vBegStg(\kNrm)$ & value at entry to {stage} (before shocks) \\
      {\Decision}(s)  & (blank)            & $\mNrm$ & $\vMidStg(\mNrm)$ & value of {stage}-decision (after shocks)       \\
      {\Continuation} & $ \cntn $ & $\aNrm$ & $\vEndStg(\aNrm)$ & value at exit (after decision) \\ \hline
    \end{tabular}
%  }
  \end{center}

  Notice that the value functions at different {step}s of the {stage} have distinct state variables.  Only $\kNrm$ is known at the beginning of the period, and other variables take on their values with equations like $b = k \RNrm$ and $\mNrm = \bNrm+\TranShkEmp.$  We will refer to such within-the-{stage} creation of variables as {evolutions}.%  Thus, the consumption problem has two {evolutions}: from $\kNrm$ to $\mNrm$ and from $\mNrm$ to $\aNrm$.

\subsection{Transitions}

  In the backward-induction world of Bellman solutions, to solve the problem of a particular {period} we must start with an end-of-{period} value function, which we designate by including the {period} indicator in the subscript:
  \begin{equation}\begin{gathered}\begin{aligned}
        \vEndPrd(\aNrm) & \mapsto \DiscFac \vBegPrdNxt(\overbrace{\aNrm}^{=\kNrm}), \label{eq:trns-single-prd}
  \end{aligned}\end{gathered}\end{equation}
and we are not done solving the problem of the entire {period} until we have constructed a beginning-of-{period} value function $\vBegPrd(\kNrm)$.

Once we are inside a {stage}, we will also need an end-of-{stage} value function.  For the last {stage} in a {period} the end-of-{stage} function is taken to be end-of-{period} value function:
  \begin{equation}\begin{gathered}\begin{aligned}
        \vEndStg(\aNrm) \mapsto \vEndPrd(\aNrm).
      \end{aligned}\end{gathered}\end{equation}

One way to describe this is that when we are considering the solution to the current {stage}, we will be working with what, in computer programming, is called a `local function' $\vEndStg(a)$ whose value at the beginning of the {stage}-solution algorithm has been initialized to the value of a previously-computed `global function' $\vEndPrd(a)$ that had already been constructed by mapping itself to $\DiscFac \vBegPrdNxt$ (equation \eqref{eq:trns-single-prd}).
\hypertarget{decision-problem}{}

\subsection{The Decision Problem in the New Notation}\label{subsec:decision-problem}

The {\Decision} problem can now be written much more cleanly than in equation \eqref{eq:vNormed}:
\begin{verbatimwrite}{./Equations/vMid}
  \begin{equation}\begin{gathered}\begin{aligned}
        \vFunc(\mNrm) & = \max_{\cNrm}~ \uFunc(\cNrm) + \vFunc_{_\cntn}(\overbrace{\mNrm-\cFunc}^{\aNrm}) \label{eq:vMid}
      \end{aligned}\end{gathered}\end{equation}
\end{verbatimwrite}
\input{./Equations/vMid}\unskip
whose first order condition with respect to $\cNrm$ is
\begin{equation}\begin{gathered}\begin{aligned}
  \uFunc^{\cNrm}(\cNrm) &= \vEndStg^{\aNrm}(\mNrm-\cNrm)  \label{eq:upEqbetaOp} 
\end{aligned}\end{gathered}\end{equation}
which is mathematically equivalent to the usual Euler equation for consumption.  (We will reuse this formulation when we turn to section~\ref{subsec:egm}.)

Having defined these notational conventions, we are now ready to move to substance.

\begin{comment} %

  %
  \subsection{Implementation in Python}

  The code implementing the tasks outlined each of the sections to come is available in the \texttt{\href{https://econ-ark.org/materials/SolvingMicroDSOPs}{SolvingMicroDSOPs}} jupyter notebook, written in \href{https://python.org}{Python}. The notebook imports various modules, including the standard \texttt{numpy} and \texttt{scipy} modules used for numerical methods in Python, as well as some user-defined modules designed to provide numerical solutions to the consumer's problem from the previous section. Before delving into the computational exercise, it is essential to touch on the practicality of these custom modules.

  \subsubsection{Useful auxilliary files}

  In this exercise, two primary user-defined modules are frequently imported and utilized. The first is the \texttt{gothic\_class} module, which contains functions describing the end-of-period value functions found in equations \eqref{eq:vBegStg} - \eqref{eq:vEnd} (and the corresponding first and second derivatives). %The advantage of defining functions in the code which decompose the consumer's optimal behavior in a given period will become evident in section \ref{subsec:transformation}

  The \texttt{resources} module is also used repeatedly throughout the notebook. This file has three primary objectives: (i) providing functions that discretize the continuous distributions from the theoretical model that describe the uncertainty a consumer faces, (ii) defining the utility function over consumption under a number of specifications, and (iii) enhancing the grid of end-of-period assets for which functions (such as those from the \texttt{gothic\_class} module) will be defined. These objectives will be discussed in greater detail and with respect to the numerical methods used to the problem in subsequent sections of this document.
\end{comment}

\end{document}
